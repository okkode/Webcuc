@using MudBlazor
@using GdeWeb.Interfaces
@using GdeWebModels
@using Microsoft.JSInterop
@using Blazored.LocalStorage
@inject INoteService NoteService
@inject ISnackbarService SnackbarService
@inject IConfiguration Configuration
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorage
@implements IAsyncDisposable

<MudDialog>
    <DialogContent>
        <MudContainer>
            <MudTextField @bind-Value="noteTitle"
                          Label="Jegyzet címe"
                          Variant="Variant.Outlined"
                          FullWidth="true"
                          Required="true"
                          RequiredError="A cím kötelező"
                          Margin="Margin.Normal" />

            <MudTextField @bind-Value="noteContent"
                          Label="Jegyzet tartalma"
                          Variant="Variant.Outlined"
                          Lines="10"
                          FullWidth="true"
                          Margin="Margin.Normal" />

            @if (showVoiceInput)
            {
                <MudPaper Class="pa-2 ma-2" Elevation="1">
                    <MudText Typo="Typo.body2">Hangfelvétel (Real-time)</MudText>
                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                        @if (!isRecording)
                        {
                            <MudButton Variant="Variant.Filled"
                                       Color="Color.Error"
                                       StartIcon="@Icons.Material.Filled.Mic"
                                       OnClick="StartVoiceRecording">
                                Felvétel indítása
                            </MudButton>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Filled"
                                       Color="Color.Error"
                                       StartIcon="@Icons.Material.Filled.Stop"
                                       OnClick="StopVoiceRecording">
                                Felvétel leállítása
                            </MudButton>
                            <MudProgressCircular Indeterminate="true" Size="Size.Small" Color="Color.Error" />
                            <MudText Typo="Typo.caption" Color="Color.Error">● FELVÉTEL</MudText>
                        }
                    </MudStack>
                    @if (!string.IsNullOrEmpty(currentInterimText))
                    {
                        <MudAlert Severity="Severity.Info" Dense="true" Class="mt-2">
                            <MudText Typo="Typo.caption">
                                <em>@currentInterimText</em>
                            </MudText>
                        </MudAlert>
                    }
                    @if (!string.IsNullOrEmpty(lastRecordedText))
                    {
                        <MudText Typo="Typo.caption" Class="mt-2" Color="Color.Success">
                            Legutóbb rögzített: @lastRecordedText
                        </MudText>
                    }
                </MudPaper>
            }

            <MudStack Row="true" Spacing="2" Justify="Justify.FlexEnd" Class="mt-2">
                <MudButton Variant="Variant.Outlined"
                           Color="Color.Secondary"
                           StartIcon="@Icons.Material.Filled.Mic"
                           OnClick="ToggleVoiceInput">
                    @(showVoiceInput ? "Hang bevitel elrejtése" : "Hang bevitel")
                </MudButton>
            </MudStack>
        </MudContainer>
    </DialogContent>

    <DialogActions>
        <MudButton Variant="Variant.Outlined" Color="Color.Default" OnClick="Cancel">Mégsem</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Save" Disabled="@isSaving">
            @if (isSaving)
            {
                <MudProgressCircular Indeterminate="true" Size="Size.Small" Class="mr-2" />
            }
            Mentés
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] private IMudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public int CourseId { get; set; }
    [Parameter] public NoteModel? ExistingNote { get; set; }

    private string noteTitle = string.Empty;
    private string noteContent = string.Empty;
    private bool isSaving = false;
    private bool showVoiceInput = false;
    private bool isRecording = false;
    private string currentInterimText = string.Empty;
    private string lastRecordedText = string.Empty;
    private string baseContent = string.Empty; // A felvétel indításakor lévő tartalom

    protected override void OnInitialized()
    {
        if (ExistingNote != null)
        {
            noteTitle = ExistingNote.NoteTitle;
            noteContent = ExistingNote.NoteContent;
        }
    }

    private void Cancel() => MudDialog.Cancel();

    private async Task Save()
    {
        if (string.IsNullOrWhiteSpace(noteTitle))
        {
            SnackbarService.ShowSnackbar(Severity.Warning, "A cím kötelező!", 3000);
            return;
        }

        isSaving = true;
        try
        {
            var note = new NoteModel
            {
                NoteId = ExistingNote?.NoteId ?? 0,
                CourseId = CourseId,
                NoteTitle = noteTitle.Trim(),
                NoteContent = noteContent.Trim()
            };

            ResultModel result;
            if (ExistingNote != null)
            {
                result = await NoteService.ModifyNote(note);
            }
            else
            {
                result = await NoteService.AddNote(note);
            }

            if (result.Success)
            {
                SnackbarService.ShowSnackbar(Severity.Success, "Jegyzet sikeresen mentve!", 3000);
                MudDialog.Close(DialogResult.Ok<NoteModel>(note));
            }
            else
            {
                SnackbarService.ShowSnackbar(Severity.Error, $"Hiba történt: {result.ErrorMessage}", 5000);
            }
        }
        catch (Exception ex)
        {
            SnackbarService.ShowSnackbar(Severity.Error, $"Hiba történt: {ex.Message}", 5000);
        }
        finally
        {
            isSaving = false;
        }
    }

    private void ToggleVoiceInput()
    {
        showVoiceInput = !showVoiceInput;
    }

    private DotNetObjectReference<NoteDialog>? dotNetRef;
    private IJSObjectReference? jsModule;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            try
            {
                jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "/js/recorderEvents.js");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JS modul betöltési hiba: {ex.Message}");
            }
        }
    }

    private async Task StartVoiceRecording()
    {
        try
        {
            if (jsModule == null || dotNetRef == null)
            {
                SnackbarService.ShowSnackbar(Severity.Warning, "Hangfelvétel nem elérhető ebben a böngészőben.", 3000);
                return;
            }

            // Eltároljuk a jelenlegi tartalmat
            baseContent = noteContent;
            currentInterimText = string.Empty;
            lastRecordedText = string.Empty;

            isRecording = true;
            await jsModule.InvokeVoidAsync("startRecording", dotNetRef);
            SnackbarService.ShowSnackbar(Severity.Info, "Hangfelvétel elindítva. Beszélj a mikrofonba...", 2000);
        }
        catch (Exception ex)
        {
            isRecording = false;
            SnackbarService.ShowSnackbar(Severity.Error, $"Hiba a hangfelvétel indításakor: {ex.Message}", 5000);
        }
    }

    private async Task StopVoiceRecording()
    {
        try
        {
            if (jsModule == null)
            {
                isRecording = false;
                return;
            }

            isRecording = false;

            // Várunk egy kicsit, hogy az utolsó result esemény is beérkezzen
            await Task.Delay(500);

            var finalText = await jsModule.InvokeAsync<string>("stopRecording");

            Console.WriteLine($"Final text from JS: '{finalText}'");
            Console.WriteLine($"Current noteContent: '{noteContent}'");

            if (!string.IsNullOrEmpty(finalText))
            {
                lastRecordedText = finalText.Length > 50 ? finalText.Substring(0, 50) + "..." : finalText;

                // Ha a noteContent még nem tartalmazza a teljes szöveget, hozzáadjuk
                if (!noteContent.Contains(finalText))
                {
                    if (string.IsNullOrEmpty(baseContent))
                    {
                        noteContent = finalText;
                    }
                    else
                    {
                        noteContent = baseContent + "\n\n" + finalText;
                    }
                }

                SnackbarService.ShowSnackbar(Severity.Success, $"Hangfelvétel befejezve! ({finalText.Length} karakter)", 3000);
            }
            else
            {
                SnackbarService.ShowSnackbar(Severity.Warning, "Nem sikerült felismerni a beszédet. Próbáld újra!", 3000);
            }

            currentInterimText = string.Empty;

            // Reset JS transcript
            await jsModule.InvokeVoidAsync("resetTranscript");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in StopVoiceRecording: {ex.Message}");
            SnackbarService.ShowSnackbar(Severity.Error, $"Hiba a hangfelvétel leállításakor: {ex.Message}", 5000);
        }
        finally
        {
            isRecording = false;
            StateHasChanged();
        }
    }

    // Ez a metódus folyamatosan frissíti a jegyzet tartalmát a felismert szöveggel
    [JSInvokable]
    public void OnTranscriptUpdate(string transcript)
    {
        InvokeAsync(() =>
        {
            Console.WriteLine($"OnTranscriptUpdate called with: '{transcript}'");

            if (!string.IsNullOrEmpty(transcript))
            {
                // Frissítjük a jegyzet tartalmát
                if (string.IsNullOrEmpty(baseContent))
                {
                    noteContent = transcript;
                }
                else
                {
                    noteContent = baseContent + "\n\n" + transcript;
                }

                Console.WriteLine($"Updated noteContent: '{noteContent}'");
                StateHasChanged();
            }
        });
    }

    // Ez a metódus mutatja a köztes (még nem véglegesített) felismerést
    [JSInvokable]
    public void OnInterimTranscript(string interimText)
    {
        InvokeAsync(() =>
        {
            currentInterimText = interimText;
            StateHasChanged();
        });
    }

    [JSInvokable]
    public void OnRecordingStopped(string message)
    {
        InvokeAsync(async () =>
        {
            if (isRecording)
            {
                await StopVoiceRecording();
            }
        });
    }

    [JSInvokable]
    public void OnRecordingError(string error)
    {
        InvokeAsync(() =>
        {
            isRecording = false;
            currentInterimText = string.Empty;
            SnackbarService.ShowSnackbar(Severity.Error, error, 5000);
            StateHasChanged();
        });
    }

    public async ValueTask DisposeAsync()
    {
        if (isRecording && jsModule != null)
        {
            try
            {
                await jsModule.InvokeVoidAsync("stopRecording");
            }
            catch { }
        }

        if (dotNetRef != null)
        {
            dotNetRef.Dispose();
        }

        if (jsModule != null)
        {
            try
            {
                await jsModule.DisposeAsync();
            }
            catch { }
        }
    }
}