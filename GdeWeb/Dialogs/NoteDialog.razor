@using MudBlazor
@using GdeWeb.Interfaces
@using GdeWebModels
@using Microsoft.JSInterop
@using Blazored.LocalStorage
@inject INoteService NoteService
@inject ISnackbarService SnackbarService
@inject IConfiguration Configuration
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorage
@implements IAsyncDisposable

<MudDialog>
    <DialogContent>
        <MudContainer>
            <MudTextField @bind-Value="noteTitle"
                          Label="Jegyzet címe"
                          Variant="Variant.Outlined"
                          FullWidth="true"
                          Required="true"
                          RequiredError="A cím kötelező"
                          Margin="Margin.Normal" />

            <MudTextField @bind-Value="noteContent"
                          Label="Jegyzet tartalma"
                          Variant="Variant.Outlined"
                          Lines="10"
                          FullWidth="true"
                          Margin="Margin.Normal" />

            @if (showVoiceInput)
            {
                <MudPaper Class="pa-2 ma-2" Elevation="1">
                    <MudText Typo="Typo.body2">Hangfelvétel</MudText>
                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                        @if (!isRecording)
                        {
                            <MudButton Variant="Variant.Filled" 
                                      Color="Color.Error" 
                                      StartIcon="@Icons.Material.Filled.Mic"
                                      OnClick="StartVoiceRecording">
                                Felvétel indítása
                            </MudButton>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Filled" 
                                      Color="Color.Error" 
                                      StartIcon="@Icons.Material.Filled.Stop"
                                      OnClick="StopVoiceRecording">
                                Felvétel leállítása
                            </MudButton>
                            <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                        }
                    </MudStack>
                    @if (!string.IsNullOrEmpty(transcribedText))
                    {
                        <MudText Typo="Typo.caption" Class="mt-2">Felismert szöveg: @transcribedText</MudText>
                    }
                </MudPaper>
            }

            <MudStack Row="true" Spacing="2" Justify="Justify.FlexEnd" Class="mt-2">
                <MudButton Variant="Variant.Outlined" 
                          Color="Color.Secondary" 
                          StartIcon="@Icons.Material.Filled.Mic"
                          OnClick="ToggleVoiceInput">
                    @(showVoiceInput ? "Hang bevitel elrejtése" : "Hang bevitel")
                </MudButton>
            </MudStack>
        </MudContainer>
    </DialogContent>

    <DialogActions>
        <MudButton Variant="Variant.Outlined" Color="Color.Default" OnClick="Cancel">Mégsem</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Save" Disabled="@isSaving">
            @if (isSaving)
            {
                <MudProgressCircular Indeterminate="true" Size="Size.Small" Class="mr-2" />
            }
            Mentés
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] private IMudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public int CourseId { get; set; }
    [Parameter] public NoteModel? ExistingNote { get; set; }

    private string noteTitle = string.Empty;
    private string noteContent = string.Empty;
    private bool isSaving = false;
    private bool showVoiceInput = false;
    private bool isRecording = false;
    private string transcribedText = string.Empty;

    protected override void OnInitialized()
    {
        if (ExistingNote != null)
        {
            noteTitle = ExistingNote.NoteTitle;
            noteContent = ExistingNote.NoteContent;
        }
    }

    private void Cancel() => MudDialog.Cancel();

    private async Task Save()
    {
        if (string.IsNullOrWhiteSpace(noteTitle))
        {
            SnackbarService.ShowSnackbar(Severity.Warning, "A cím kötelező!", 3000);
            return;
        }

        isSaving = true;
        try
        {
            var note = new NoteModel
            {
                NoteId = ExistingNote?.NoteId ?? 0,
                CourseId = CourseId,
                NoteTitle = noteTitle.Trim(),
                NoteContent = noteContent.Trim()
            };

            ResultModel result;
            if (ExistingNote != null)
            {
                result = await NoteService.ModifyNote(note);
            }
            else
            {
                result = await NoteService.AddNote(note);
            }

            if (result.Success)
            {
                SnackbarService.ShowSnackbar(Severity.Success, "Jegyzet sikeresen mentve!", 3000);
                MudDialog.Close(DialogResult.Ok<NoteModel>(note));
            }
            else
            {
                SnackbarService.ShowSnackbar(Severity.Error, $"Hiba történt: {result.ErrorMessage}", 5000);
            }
        }
        catch (Exception ex)
        {
            SnackbarService.ShowSnackbar(Severity.Error, $"Hiba történt: {ex.Message}", 5000);
        }
        finally
        {
            isSaving = false;
        }
    }

    private void ToggleVoiceInput()
    {
        showVoiceInput = !showVoiceInput;
    }

    private DotNetObjectReference<NoteDialog>? dotNetRef;
    private IJSObjectReference? jsModule;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            try
            {
                jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "/js/recorderEvents.js");
            }
            catch
            {
                // JS module might not be available
            }
        }
    }

    private async Task StartVoiceRecording()
    {
        try
        {
            if (jsModule == null || dotNetRef == null)
            {
                SnackbarService.ShowSnackbar(Severity.Warning, "Hangfelvétel nem elérhető ebben a böngészőben.", 3000);
                return;
            }

            isRecording = true;
            await jsModule.InvokeVoidAsync("startRecording", dotNetRef);
            SnackbarService.ShowSnackbar(Severity.Info, "Hangfelvétel elindítva. Beszélj a mikrofonba...", 2000);
        }
        catch (Exception ex)
        {
            isRecording = false;
            SnackbarService.ShowSnackbar(Severity.Error, $"Hiba a hangfelvétel indításakor: {ex.Message}", 5000);
        }
    }

    private async Task StopVoiceRecording()
    {
        try
        {
            if (jsModule == null)
            {
                isRecording = false;
                return;
            }

            var apiUrl = Configuration["apiUrl"]?.ToString() ?? "";
            var accessToken = await LocalStorage.GetItemAsync<string>("token");
            
            if (string.IsNullOrEmpty(accessToken))
            {
                SnackbarService.ShowSnackbar(Severity.Error, "Token nem található!", 3000);
                isRecording = false;
                return;
            }

            var transcribedTextResult = await jsModule.InvokeAsync<string>("stopRecording", apiUrl, accessToken);
            
            if (!string.IsNullOrEmpty(transcribedTextResult))
            {
                transcribedText = transcribedTextResult;
                noteContent += (string.IsNullOrEmpty(noteContent) ? "" : "\n\n") + transcribedText;
                transcribedText = string.Empty;
                SnackbarService.ShowSnackbar(Severity.Success, "Hangfelvétel sikeresen leírva!", 3000);
            }
            else
            {
                SnackbarService.ShowSnackbar(Severity.Warning, "Nem sikerült felismerni a beszédet.", 3000);
            }
        }
        catch (Exception ex)
        {
            SnackbarService.ShowSnackbar(Severity.Error, $"Hiba a hangfelvétel leállításakor: {ex.Message}", 5000);
        }
        finally
        {
            isRecording = false;
        }
    }

    [JSInvokable]
    public void OnRecordingStopped(string message)
    {
        InvokeAsync(async () =>
        {
            if (isRecording)
            {
                await StopVoiceRecording();
            }
        });
    }

    [JSInvokable]
    public void OnRecordingError(string error)
    {
        InvokeAsync(() =>
        {
            isRecording = false;
            SnackbarService.ShowSnackbar(Severity.Error, error, 5000);
            StateHasChanged();
        });
    }

    public async ValueTask DisposeAsync()
    {
        if (dotNetRef != null)
        {
            dotNetRef.Dispose();
        }
        if (jsModule != null)
        {
            try
            {
                await jsModule.DisposeAsync();
            }
            catch { }
        }
    }
}

